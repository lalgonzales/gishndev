{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to gishndev","text":"<p>A package to developed tools to processing gis data</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://lalgonzales.github.io/gishndev</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>GEE S2 Functions</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#gishndev.common.hello_world","title":"<code>hello_world()</code>","text":"<p>Prints \"Hello World!\" to the console.</p> Source code in <code>gishndev/common.py</code> <pre><code>def hello_world():\n    \"\"\"Prints \"Hello World!\" to the console.\"\"\"\n    print(\"Hello World!\")\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/lalgonzales/gishndev/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>gishndev could always use more documentation, whether as part of the official gishndev docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/lalgonzales/gishndev/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up gishndev for local development.</p> <ol> <li> <p>Fork the gishndev repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/gishndev.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv gishndev\n$ cd gishndev/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 gishndev tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/lalgonzales/gishndev/pulls and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"gee_funcs/","title":"gee_funcs module","text":"<p>This module contains functions for working with satellite images and Google Earth Engine.</p>"},{"location":"gee_funcs/#gishndev.gee_funcs.apply_scale_factorsL8","title":"<code>apply_scale_factorsL8(img)</code>","text":"<p>Applies scale factors to Landsat 8 imagery bands.</p> <p>This function scales the optical and thermal bands of a Landsat 8 image. The optical bands are scaled by multiplying by 0.0000275 and adding -0.2. The thermal bands are scaled by multiplying by 0.00341802 and adding 149.0.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>The input Landsat 8 image to which the scale factors will be applied.</p> required <p>Returns:</p> Type Description <code>ee.Image</code> <p>The image with scaled optical and thermal bands.</p> Source code in <code>gishndev/gee_funcs.py</code> <pre><code>def apply_scale_factorsL8(img):\n    \"\"\"\n    Applies scale factors to Landsat 8 imagery bands.\n\n    This function scales the optical and thermal bands of a Landsat 8 image.\n    The optical bands are scaled by multiplying by 0.0000275 and adding -0.2.\n    The thermal bands are scaled by multiplying by 0.00341802 and adding 149.0.\n\n    Args:\n        img (ee.Image): The input Landsat 8 image to which the scale factors will be applied.\n\n    Returns:\n        ee.Image: The image with scaled optical and thermal bands.\n    \"\"\"\n    optical_bands = img.select(\"SR_B.\").multiply(0.0000275).add(-0.2)\n    thermal_bands = img.select(\"ST_B.*\").multiply(0.00341802).add(149.0)\n    return img.addBands(optical_bands, None, True).addBands(thermal_bands, None, True)\n</code></pre>"},{"location":"gee_funcs/#gishndev.gee_funcs.compute_index","title":"<code>compute_index(img, index, params)</code>","text":"<p>Computes spectral indices for the given image and adds them as bands.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>The input image to which the spectral indices will be added.</p> required <code>index</code> <code>list or str</code> <p>A list of spectral indices to compute. If a single index is provided, it will be converted to a list.</p> required <code>params</code> <code>dict</code> <p>A dictionary of parameters required for computing the indices.</p> required <p>Returns:</p> Type Description <code>ee.Image</code> <p>The input image with the computed spectral indices added as bands.</p> Source code in <code>gishndev/gee_funcs.py</code> <pre><code>def compute_index(img, index, params):\n    \"\"\"\n    Computes spectral indices for the given image and adds them as bands.\n\n    Args:\n        img (ee.Image): The input image to which the spectral indices will be added.\n        index (list or str): A list of spectral indices to compute. If a single index is provided, it will be converted to a list.\n        params (dict): A dictionary of parameters required for computing the indices.\n\n    Returns:\n        ee.Image: The input image with the computed spectral indices added as bands.\n    \"\"\"\n    if not isinstance(index, list):\n        index = [index]\n\n    for idx in index:\n        formula = spectral_indices[idx][\"formula\"]\n        img = img.addBands(img.expression(formula, params).rename(idx))\n\n    return img\n</code></pre>"},{"location":"gee_funcs/#gishndev.gee_funcs.index_info","title":"<code>index_info(index, properties=None)</code>","text":"<p>Retrieve and print information about specified spectral indices.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>str or list of str</code> <p>A single index or a list of indices to retrieve information for.</p> required <code>properties</code> <code>list of str</code> <p>A list of properties to retrieve for each index. Default is [\"formula\"].                                 Possible properties include 'application_domain', 'bands', 'contributor',                                 'date_of_addition', 'formula', 'long_name', 'platforms',                                 'reference', 'short_name'.</p> <code>None</code> Source code in <code>gishndev/gee_funcs.py</code> <pre><code>def index_info(index, properties=None):\n    \"\"\"\n    Retrieve and print information about specified spectral indices.\n\n    Args:\n        index (str or list of str): A single index or a list of indices to retrieve information for.\n        properties (list of str, optional): A list of properties to retrieve for each index. Default is [\"formula\"].\n                                            Possible properties include 'application_domain', 'bands', 'contributor',\n                                            'date_of_addition', 'formula', 'long_name', 'platforms',\n                                            'reference', 'short_name'.\n    \"\"\"\n    if properties is None:\n        properties = [\"formula\"]\n\n    if not isinstance(index, list):\n        index = [index]\n\n    if not isinstance(properties, list):\n        properties = [properties]\n\n    for idx in index:\n        properties_dic = {}\n        for prop in properties:\n            properties_dic[prop] = spectral_indices[idx][prop]\n        print(f\"'{idx}' info:\")\n        print(properties_dic)\n</code></pre>"},{"location":"gee_funcs/#gishndev.gee_funcs.mask_s2_clouds","title":"<code>mask_s2_clouds(img)</code>","text":"<p>Masks clouds and cloud shadows in Sentinel-2 images using the SCL band, QA60 band, and cloud probability.</p> <p>This function applies a series of masks to a Sentinel-2 image to remove pixels that are likely to be affected by clouds, cloud shadows, cirrus, or snow. It uses the Scene Classification Layer (SCL) band, the QA60 band, and optionally the cloud probability band from the COPERNICUS/S2_CLOUD_PROBABILITY collection.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ee.Image</code> <p>The Sentinel-2 image to be masked.</p> required <p>Returns:</p> Type Description <code>ee.Image</code> <p>The masked Sentinel-2 image with values scaled between 0 and 1.</p> Source code in <code>gishndev/gee_funcs.py</code> <pre><code>def mask_s2_clouds(img):\n    \"\"\"\n    Masks clouds and cloud shadows in Sentinel-2 images using the SCL band, QA60 band, and cloud probability.\n\n    This function applies a series of masks to a Sentinel-2 image to remove pixels that are likely to be affected by clouds, cloud shadows, cirrus, or snow. It uses the Scene Classification Layer (SCL) band, the QA60 band, and optionally the cloud probability band from the COPERNICUS/S2_CLOUD_PROBABILITY collection.\n\n    Args:\n        img (ee.Image): The Sentinel-2 image to be masked.\n\n    Returns:\n        ee.Image: The masked Sentinel-2 image with values scaled between 0 and 1.\n    \"\"\"\n    # Load the cloud probability image collection\n    cloud_prob_collection = (\n        ee.ImageCollection(\"COPERNICUS/S2_CLOUD_PROBABILITY\")\n        .filterBounds(img.geometry())\n        .filterDate(img.date(), img.date().advance(1, \"day\"))\n    )\n\n    # Get the first cloud probability image if available\n    cloud_prob_img = ee.Algorithms.If(\n        cloud_prob_collection.size().gt(0),\n        cloud_prob_collection.first(),  # Use cloud probability image if it exists\n        None,  # Otherwise, return None to skip cloud probability masking\n    )\n\n    # Use the SCL band for scene classification\n    scl = img.select(\"SCL\")\n\n    # Create masks based on the SCL band\n    scl_mask = (\n        scl.neq(3)\n        .And(scl.neq(8))  # 3 = Cloud shadow\n        .And(scl.neq(9))  # 8 = Clouds\n        .And(scl.neq(10))  # 9 = Cirrus\n    )  # 10 = Snow\n\n    # QA60 mask for clouds and cirrus\n    qa = img.select(\"QA60\")\n    cloud_bit_mask = ee.Number(1024)  # 2^10 = 1024, 10th bit is clouds\n    cirrus_bit_mask = ee.Number(2048)  # 2^11 = 2048, 11th bit is cirrus clouds\n    mask_qa60 = (\n        qa.bitwiseAnd(cloud_bit_mask).eq(0).And(qa.bitwiseAnd(cirrus_bit_mask).eq(0))\n    )\n\n    # Use cloud probability threshold (e.g., clouds if probability &gt; 20%)\n    cloud_prob_mask = ee.Image(cloud_prob_img).select(\"probability\").lt(20)\n\n    # Combine the SCL mask, QA60 mask, and cloud probability mask (if available)\n    combined_mask = ee.Algorithms.If(\n        cloud_prob_img,  # If cloud_prob_image is not None\n        scl_mask.And(mask_qa60).And(cloud_prob_mask),  # Combine all masks\n        scl_mask.And(\n            mask_qa60\n        ),  # Use only SCL and QA60 mask if cloud probability image is unavailable\n    )\n\n    # Return the masked image, scaled by 10,000 to get values between 0-1\n    return img.updateMask(combined_mask)\n</code></pre>"},{"location":"gee_funcs/#gishndev.gee_funcs.params_index_s2","title":"<code>params_index_s2(index, img)</code>","text":"<p>Processes spectral indices and returns a dictionary of parameters with their corresponding values or bands.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>list or str</code> <p>A list of spectral index names or a single spectral index name.</p> required <code>img</code> <code>ee.Image</code> <p>An image object from which bands are selected.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary where keys are parameter names and values are either constants or selected bands from the image.</p> Source code in <code>gishndev/gee_funcs.py</code> <pre><code>def params_index_s2(index, img):\n    \"\"\"\n    Processes spectral indices and returns a dictionary of parameters with their corresponding values or bands.\n\n    Args:\n        index (list or str): A list of spectral index names or a single spectral index name.\n        img (ee.Image): An image object from which bands are selected.\n\n    Returns:\n        dict: A dictionary where keys are parameter names and values are either constants or selected bands from the image.\n    \"\"\"\n    # Convertir a lista sino lo es``\n    if not isinstance(index, list):\n        index = [index]\n\n    # Obtener los par\u00e1metros de los \u00edndices\n    unique_params = []\n    for idx in index:\n        idx_params = spectral_indices[idx][\"bands\"]\n        total_params = unique_params + idx_params\n        unique_params = list(set(total_params))\n\n    ##  Crear las constantes\n    param_constants = [\n        param for param in unique_params if param in spectral_constants.keys()\n    ]\n    constants_values = {}\n    for constant in param_constants:\n        value = spectral_constants[constant][\"default\"]\n        constants_values[constant] = value\n\n    ## Asignar la banda de sentinel a cada params_bands\n    param_bands = [\n        param for param in unique_params if param not in spectral_constants.keys()\n    ]\n    s2_param_bands = {}\n    for band in param_bands:\n        s2_band = spectral_bands[band][\"platforms\"][\"sentinel2a\"][\"band\"]\n        s2_param_bands[band] = s2_band\n\n    ## Crear los par\u00e1metros\n    params = {}\n    for param in unique_params:\n        if param in constants_values.keys():\n            value = constants_values[param]\n            params[param] = value\n        elif param in s2_param_bands.keys():\n            band_name = s2_param_bands[param]\n            params[param] = img.select(band_name)\n    return params\n</code></pre>"},{"location":"gishndev/","title":"gishndev module","text":"<p>Main module.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install gishndev, run this command in your terminal:</p> <pre><code>pip install gishndev\n</code></pre> <p>This is the preferred method to install gishndev, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install gishndev from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/lalgonzales/gishndev\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use gishndev in a project:</p> <pre><code>import gishndev\n</code></pre>"},{"location":"examples/intro/","title":"Intro","text":"In\u00a0[1]: Copied! <pre>print(\"Hello World!\")\n</pre> print(\"Hello World!\") <pre>Hello World!\n</pre>"},{"location":"examples/s2_composite/","title":"S2 composite","text":"In\u00a0[1]: Copied! <pre># !pip install gishndev\n</pre> # !pip install gishndev In\u00a0[2]: Copied! <pre>import os\nimport ee\nimport geemap\nfrom gishndev import mask_s2_clouds\n\nee.Authenticate()\nee.Initialize(\n    project=os.getenv(\"EE_PROJECT_ID\")\n)  # replace with your GEE project ID like project='my-gee-project'\n</pre> import os import ee import geemap from gishndev import mask_s2_clouds  ee.Authenticate() ee.Initialize(     project=os.getenv(\"EE_PROJECT_ID\") )  # replace with your GEE project ID like project='my-gee-project' In\u00a0[3]: Copied! <pre># Sentinel 2 collection\ns2_col = ee.ImageCollection(\"COPERNICUS/S2_SR_HARMONIZED\")\n\n# Google Cloud Score + collection\nscore_plus_col = ee.ImageCollection(\"GOOGLE/CLOUD_SCORE_PLUS/V1/S2_HARMONIZED\")\n\n# Define the date range and region of interest\nstart_date = \"2020-01-01\"\nend_date = \"2020-12-31\"\nroi = ee.FeatureCollection(\"USDOS/LSIB/2017\").filter(\n    ee.Filter.eq(\"COUNTRY_NA\", \"Honduras\")\n)\next = roi.geometry().bounds()\n\n# Get a clean collection of Sentinel 2 images\nsen2 = (\n    s2_col.filterDate(start_date, end_date)\n    .filterBounds(ext)\n    .linkCollection(score_plus_col, [\"cs_cdf\"])\n    .map(lambda img: img.updateMask(img.select(\"cs_cdf\").gte(0.5)))\n    .map(mask_s2_clouds)\n)\n\nsen2_median = sen2.median()\n</pre> # Sentinel 2 collection s2_col = ee.ImageCollection(\"COPERNICUS/S2_SR_HARMONIZED\")  # Google Cloud Score + collection score_plus_col = ee.ImageCollection(\"GOOGLE/CLOUD_SCORE_PLUS/V1/S2_HARMONIZED\")  # Define the date range and region of interest start_date = \"2020-01-01\" end_date = \"2020-12-31\" roi = ee.FeatureCollection(\"USDOS/LSIB/2017\").filter(     ee.Filter.eq(\"COUNTRY_NA\", \"Honduras\") ) ext = roi.geometry().bounds()  # Get a clean collection of Sentinel 2 images sen2 = (     s2_col.filterDate(start_date, end_date)     .filterBounds(ext)     .linkCollection(score_plus_col, [\"cs_cdf\"])     .map(lambda img: img.updateMask(img.select(\"cs_cdf\").gte(0.5)))     .map(mask_s2_clouds) )  sen2_median = sen2.median() In\u00a0[4]: Copied! <pre>m = geemap.Map()\nm.center_object(roi, zoom=8)\nm.add_layer(\n    sen2_median, {\"bands\": [\"B4\", \"B3\", \"B2\"], \"min\": 0, \"max\": 2000}, \"Sentinel 2\"\n)\nm\n</pre> m = geemap.Map() m.center_object(roi, zoom=8) m.add_layer(     sen2_median, {\"bands\": [\"B4\", \"B3\", \"B2\"], \"min\": 0, \"max\": 2000}, \"Sentinel 2\" ) m Out[4]:"},{"location":"examples/s2_composite/#sentinel-2-composite-using-mask_s2_clouds","title":"Sentinel 2 composite using mask_s2_clouds\u00b6","text":"<p>This notebook show how can you get clean composites using the function, this function apply diferents filters to the image to get a clean composite.</p>"}]}